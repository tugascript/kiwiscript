// Copyright (C) 2024 Afonso Barracha
// 
// This file is part of KiwiScript.
// 
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: series_categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSeriesCategory = `-- name: CreateSeriesCategory :one
INSERT INTO "series_categories" (
  "series_id",
  "category_id"
) VALUES (
  $1,
  $2
) RETURNING series_id, category_id, created_at
`

type CreateSeriesCategoryParams struct {
	SeriesID   int32
	CategoryID int32
}

func (q *Queries) CreateSeriesCategory(ctx context.Context, arg CreateSeriesCategoryParams) (SeriesCategory, error) {
	row := q.db.QueryRow(ctx, createSeriesCategory, arg.SeriesID, arg.CategoryID)
	var i SeriesCategory
	err := row.Scan(&i.SeriesID, &i.CategoryID, &i.CreatedAt)
	return i, err
}

const deleteSeriesCategory = `-- name: DeleteSeriesCategory :exec
DELETE FROM "series_categories"
WHERE "series_id" = $1 AND "category_id" = $2
`

type DeleteSeriesCategoryParams struct {
	SeriesID   int32
	CategoryID int32
}

func (q *Queries) DeleteSeriesCategory(ctx context.Context, arg DeleteSeriesCategoryParams) error {
	_, err := q.db.Exec(ctx, deleteSeriesCategory, arg.SeriesID, arg.CategoryID)
	return err
}

const findCategorySeries = `-- name: FindCategorySeries :many
SELECT series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.total_duration_seconds, series.review_avg, series.review_count, series.is_published, series.author_id, series.created_at, series.updated_at FROM "series_categories"
LEFT JOIN "series" ON "series"."id" = "series_categories"."series_id"
WHERE "category_id" = $1
`

type FindCategorySeriesRow struct {
	ID                   pgtype.Int4
	Title                pgtype.Text
	Slug                 pgtype.Text
	Description          pgtype.Text
	PartsCount           pgtype.Int2
	LecturesCount        pgtype.Int2
	TotalDurationSeconds pgtype.Int4
	ReviewAvg            pgtype.Int2
	ReviewCount          pgtype.Int4
	IsPublished          pgtype.Bool
	AuthorID             pgtype.Int4
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
}

func (q *Queries) FindCategorySeries(ctx context.Context, categoryID int32) ([]FindCategorySeriesRow, error) {
	rows, err := q.db.Query(ctx, findCategorySeries, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindCategorySeriesRow{}
	for rows.Next() {
		var i FindCategorySeriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.TotalDurationSeconds,
			&i.ReviewAvg,
			&i.ReviewCount,
			&i.IsPublished,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findSeriesCategories = `-- name: FindSeriesCategories :many
SELECT categories.id, categories.title, categories.slug, categories.description, categories.author_id, categories.created_at, categories.updated_at FROM "series_categories"
LEFT JOIN "categories" ON "categories"."id" = "series_categories"."category_id"
WHERE "series_id" = $1
`

type FindSeriesCategoriesRow struct {
	ID          pgtype.Int4
	Title       pgtype.Text
	Slug        pgtype.Text
	Description pgtype.Text
	AuthorID    pgtype.Int4
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
}

func (q *Queries) FindSeriesCategories(ctx context.Context, seriesID int32) ([]FindSeriesCategoriesRow, error) {
	rows, err := q.db.Query(ctx, findSeriesCategories, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindSeriesCategoriesRow{}
	for rows.Next() {
		var i FindSeriesCategoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
