// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lectures.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLecturesBySeriesPartID = `-- name: CountLecturesBySeriesPartID :one
SELECT COUNT("id") FROM "lectures"
WHERE "series_part_id" = $1
LIMIT 1
`

func (q *Queries) CountLecturesBySeriesPartID(ctx context.Context, seriesPartID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countLecturesBySeriesPartID, seriesPartID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedLecturesBySeriesPartID = `-- name: CountPublishedLecturesBySeriesPartID :one
SELECT COUNT("id") FROM "lectures"
WHERE "series_part_id" = $1 AND "is_published" = true
LIMIT 1
`

func (q *Queries) CountPublishedLecturesBySeriesPartID(ctx context.Context, seriesPartID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishedLecturesBySeriesPartID, seriesPartID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLecture = `-- name: CreateLecture :one

INSERT INTO "lectures" (
  "title",
  "author_id",
  "series_part_id",
  "language_slug",
  "series_slug",
  "position"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  (
    SELECT COUNT("id") + 1 FROM "lectures"
    WHERE "series_part_id" = $3
  )
) RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at
`

type CreateLectureParams struct {
	Title        string
	AuthorID     int32
	SeriesPartID int32
	LanguageSlug string
	SeriesSlug   string
}

// Copyright (C) 2024 Afonso Barracha
//
// This file is part of KiwiScript.
//
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.
func (q *Queries) CreateLecture(ctx context.Context, arg CreateLectureParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, createLecture,
		arg.Title,
		arg.AuthorID,
		arg.SeriesPartID,
		arg.LanguageSlug,
		arg.SeriesSlug,
	)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementLectureCommentsCount = `-- name: DecrementLectureCommentsCount :exec
UPDATE "lectures" SET
  "comments_count" = "comments_count" - 1
WHERE "id" = $1
`

func (q *Queries) DecrementLectureCommentsCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, decrementLectureCommentsCount, id)
	return err
}

const decrementLecturePosition = `-- name: DecrementLecturePosition :exec
UPDATE "lectures" SET
  "position" = "position" - 1
WHERE 
    "series_part_id" = $1 AND 
    "position" > $2 AND 
    "position" <= $3
`

type DecrementLecturePositionParams struct {
	SeriesPartID int32
	Position     int16
	Position_2   int16
}

func (q *Queries) DecrementLecturePosition(ctx context.Context, arg DecrementLecturePositionParams) error {
	_, err := q.db.Exec(ctx, decrementLecturePosition, arg.SeriesPartID, arg.Position, arg.Position_2)
	return err
}

const deleteLectureByID = `-- name: DeleteLectureByID :exec
DELETE FROM "lectures"
WHERE "id" = $1
`

func (q *Queries) DeleteLectureByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLectureByID, id)
	return err
}

const findLectureBySlugsAndIDs = `-- name: FindLectureBySlugsAndIDs :one
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at FROM "lectures"
WHERE
  "language_slug" = $1 AND
  "series_slug" = $2 AND
  "series_part_id" = $3 AND
  "id" = $4
LIMIT 1
`

type FindLectureBySlugsAndIDsParams struct {
	LanguageSlug string
	SeriesSlug   string
	SeriesPartID int32
	ID           int32
}

func (q *Queries) FindLectureBySlugsAndIDs(ctx context.Context, arg FindLectureBySlugsAndIDsParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, findLectureBySlugsAndIDs,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SeriesPartID,
		arg.ID,
	)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLectureBySlugsAndIDsWithArticleAndVideo = `-- name: FindLectureBySlugsAndIDsWithArticleAndVideo :one
SELECT 
  lectures.id, lectures.title, lectures.position, lectures.is_published, lectures.watch_time_seconds, lectures.read_time_seconds, lectures.author_id, lectures.language_slug, lectures.series_slug, lectures.series_part_id, lectures.created_at, lectures.updated_at,
  "lecture_articles"."id" AS "article_id",
  "lecture_articles"."content" AS "article_content",
  "lecture_videos"."id" AS "video_id",
  "lecture_videos"."url" AS "video_url"
FROM "lectures"
LEFT JOIN "lecture_articles" ON "lecture_articles"."lecture_id" = "lectures"."id"
LEFT JOIN "lecture_videos" ON "lecture_videos"."lecture_id" = "lectures"."id"
WHERE
  "lectures"."language_slug" = $1 AND
  "lectures"."series_slug" = $2 AND
  "lectures"."series_part_id" = $3 AND
  "lectures"."id" = $4
LIMIT 1
`

type FindLectureBySlugsAndIDsWithArticleAndVideoParams struct {
	LanguageSlug string
	SeriesSlug   string
	SeriesPartID int32
	ID           int32
}

type FindLectureBySlugsAndIDsWithArticleAndVideoRow struct {
	ID               int32
	Title            string
	Position         int16
	IsPublished      bool
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	AuthorID         int32
	LanguageSlug     string
	SeriesSlug       string
	SeriesPartID     int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	ArticleID        pgtype.Int4
	ArticleContent   pgtype.Text
	VideoID          pgtype.Int4
	VideoUrl         pgtype.Text
}

func (q *Queries) FindLectureBySlugsAndIDsWithArticleAndVideo(ctx context.Context, arg FindLectureBySlugsAndIDsWithArticleAndVideoParams) (FindLectureBySlugsAndIDsWithArticleAndVideoRow, error) {
	row := q.db.QueryRow(ctx, findLectureBySlugsAndIDsWithArticleAndVideo,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SeriesPartID,
		arg.ID,
	)
	var i FindLectureBySlugsAndIDsWithArticleAndVideoRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArticleID,
		&i.ArticleContent,
		&i.VideoID,
		&i.VideoUrl,
	)
	return i, err
}

const findLecturesBySeriesPartID = `-- name: FindLecturesBySeriesPartID :many
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at FROM "lectures"
WHERE "series_part_id" = $1
ORDER BY "position" ASC
`

func (q *Queries) FindLecturesBySeriesPartID(ctx context.Context, seriesPartID int32) ([]Lecture, error) {
	rows, err := q.db.Query(ctx, findLecturesBySeriesPartID, seriesPartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lecture{}
	for rows.Next() {
		var i Lecture
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SeriesPartID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedLecturesBySeriesPartIDWithArticleAndVideo = `-- name: FindPaginatedLecturesBySeriesPartIDWithArticleAndVideo :many
SELECT 
  lectures.id, lectures.title, lectures.position, lectures.is_published, lectures.watch_time_seconds, lectures.read_time_seconds, lectures.author_id, lectures.language_slug, lectures.series_slug, lectures.series_part_id, lectures.created_at, lectures.updated_at,
  "lecture_articles"."id" AS "article_id",
  "lecture_articles"."content" AS "article_content",
  "lecture_videos"."id" AS "video_id",
  "lecture_videos"."url" AS "video_url"
FROM "lectures"
LEFT JOIN "lecture_articles" ON "lecture_articles"."lecture_id" = "lectures"."id"
LEFT JOIN "lecture_videos" ON "lecture_videos"."lecture_id" = "lectures"."id"
WHERE
  "lectures"."language_slug" = $1 AND
  "lectures"."series_slug" = $2 AND
  "lectures"."series_part_id" = $3
ORDER BY "position" ASC
LIMIT $4 OFFSET $5
`

type FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoParams struct {
	LanguageSlug string
	SeriesSlug   string
	SeriesPartID int32
	Limit        int32
	Offset       int32
}

type FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoRow struct {
	ID               int32
	Title            string
	Position         int16
	IsPublished      bool
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	AuthorID         int32
	LanguageSlug     string
	SeriesSlug       string
	SeriesPartID     int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	ArticleID        pgtype.Int4
	ArticleContent   pgtype.Text
	VideoID          pgtype.Int4
	VideoUrl         pgtype.Text
}

func (q *Queries) FindPaginatedLecturesBySeriesPartIDWithArticleAndVideo(ctx context.Context, arg FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoParams) ([]FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedLecturesBySeriesPartIDWithArticleAndVideo,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SeriesPartID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoRow{}
	for rows.Next() {
		var i FindPaginatedLecturesBySeriesPartIDWithArticleAndVideoRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SeriesPartID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArticleID,
			&i.ArticleContent,
			&i.VideoID,
			&i.VideoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideo = `-- name: FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideo :many
SELECT 
  lectures.id, lectures.title, lectures.position, lectures.is_published, lectures.watch_time_seconds, lectures.read_time_seconds, lectures.author_id, lectures.language_slug, lectures.series_slug, lectures.series_part_id, lectures.created_at, lectures.updated_at,
  "lecture_articles"."id" AS "article_id",
  "lecture_articles"."content" AS "article_content",
  "lecture_videos"."id" AS "video_id",
  "lecture_videos"."url" AS "video_url"
FROM "lectures"
LEFT JOIN "lecture_articles" ON "lecture_articles"."lecture_id" = "lectures"."id"
LEFT JOIN "lecture_videos" ON "lecture_videos"."lecture_id" = "lectures"."id"
WHERE
  "lectures"."language_slug" = $1 AND
  "lectures"."series_slug" = $2 AND
  "lectures"."series_part_id" = $3 AND
  "lectures"."is_published" = true
ORDER BY "position" ASC
LIMIT $4 OFFSET $5
`

type FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoParams struct {
	LanguageSlug string
	SeriesSlug   string
	SeriesPartID int32
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoRow struct {
	ID               int32
	Title            string
	Position         int16
	IsPublished      bool
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	AuthorID         int32
	LanguageSlug     string
	SeriesSlug       string
	SeriesPartID     int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	ArticleID        pgtype.Int4
	ArticleContent   pgtype.Text
	VideoID          pgtype.Int4
	VideoUrl         pgtype.Text
}

func (q *Queries) FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideo(ctx context.Context, arg FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoParams) ([]FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideo,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SeriesPartID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoRow{}
	for rows.Next() {
		var i FindPaginatedPublishedLecturesBySeriesPartIDWithArticleAndVideoRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SeriesPartID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArticleID,
			&i.ArticleContent,
			&i.VideoID,
			&i.VideoUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementLectureCommentsCount = `-- name: IncrementLectureCommentsCount :exec
UPDATE "lectures" SET
  "comments_count" = "comments_count" + 1
WHERE "id" = $1
`

func (q *Queries) IncrementLectureCommentsCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, incrementLectureCommentsCount, id)
	return err
}

const incrementLecturePosition = `-- name: IncrementLecturePosition :exec
UPDATE "lectures" SET
  "position" = "position" + 1
WHERE
  "series_part_id" = $1 AND
  "position" < $2 AND
  "position" >= $3
`

type IncrementLecturePositionParams struct {
	SeriesPartID int32
	Position     int16
	Position_2   int16
}

func (q *Queries) IncrementLecturePosition(ctx context.Context, arg IncrementLecturePositionParams) error {
	_, err := q.db.Exec(ctx, incrementLecturePosition, arg.SeriesPartID, arg.Position, arg.Position_2)
	return err
}

const updateLecture = `-- name: UpdateLecture :one
UPDATE "lectures" SET
  "title" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at
`

type UpdateLectureParams struct {
	Title string
	ID    int32
}

func (q *Queries) UpdateLecture(ctx context.Context, arg UpdateLectureParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLecture, arg.Title, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLectureIsPublished = `-- name: UpdateLectureIsPublished :one
UPDATE "lectures" SET
  "is_published" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at
`

type UpdateLectureIsPublishedParams struct {
	IsPublished bool
	ID          int32
}

func (q *Queries) UpdateLectureIsPublished(ctx context.Context, arg UpdateLectureIsPublishedParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLectureIsPublished, arg.IsPublished, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLecturePosition = `-- name: UpdateLecturePosition :one
UPDATE "lectures" SET
  "position" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at
`

type UpdateLecturePositionParams struct {
	Position int16
	ID       int32
}

func (q *Queries) UpdateLecturePosition(ctx context.Context, arg UpdateLecturePositionParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLecturePosition, arg.Position, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLectureReadTimeSeconds = `-- name: UpdateLectureReadTimeSeconds :exec
UPDATE "lectures" SET
  "read_time_seconds" = $1
WHERE "id" = $2
`

type UpdateLectureReadTimeSecondsParams struct {
	ReadTimeSeconds int32
	ID              int32
}

func (q *Queries) UpdateLectureReadTimeSeconds(ctx context.Context, arg UpdateLectureReadTimeSecondsParams) error {
	_, err := q.db.Exec(ctx, updateLectureReadTimeSeconds, arg.ReadTimeSeconds, arg.ID)
	return err
}

const updateLectureWatchTimeSeconds = `-- name: UpdateLectureWatchTimeSeconds :exec
UPDATE "lectures" SET
  "watch_time_seconds" = $1
WHERE "id" = $2
`

type UpdateLectureWatchTimeSecondsParams struct {
	WatchTimeSeconds int32
	ID               int32
}

func (q *Queries) UpdateLectureWatchTimeSeconds(ctx context.Context, arg UpdateLectureWatchTimeSecondsParams) error {
	_, err := q.db.Exec(ctx, updateLectureWatchTimeSeconds, arg.WatchTimeSeconds, arg.ID)
	return err
}

const updateLectureWithPosition = `-- name: UpdateLectureWithPosition :one
UPDATE "lectures" SET
  "title" = $1,
  "position" = $2
WHERE "id" = $3
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, series_part_id, created_at, updated_at
`

type UpdateLectureWithPositionParams struct {
	Title    string
	Position int16
	ID       int32
}

func (q *Queries) UpdateLectureWithPosition(ctx context.Context, arg UpdateLectureWithPositionParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLectureWithPosition, arg.Title, arg.Position, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SeriesPartID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
