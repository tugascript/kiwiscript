// Copyright (C) 2024 Afonso Barracha
// 
// This file is part of KiwiScript.
// 
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lectures.sql

package db

import (
	"context"
)

const createLecture = `-- name: CreateLecture :one
INSERT INTO "lectures" (
  "title",
  "video",
  "duration_seconds",
  "description",
  "author_id",
  "series_id",
  "series_part_id",
  "language_id",
  "position"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  (
    SELECT COUNT("id") + 1 FROM "lectures"
    WHERE "series_part_id" = $6
  )
) RETURNING id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at
`

type CreateLectureParams struct {
	Title           string
	Video           string
	DurationSeconds int32
	Description     string
	AuthorID        int32
	SeriesID        int32
	SeriesPartID    int32
	LanguageID      int32
}

func (q *Queries) CreateLecture(ctx context.Context, arg CreateLectureParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, createLecture,
		arg.Title,
		arg.Video,
		arg.DurationSeconds,
		arg.Description,
		arg.AuthorID,
		arg.SeriesID,
		arg.SeriesPartID,
		arg.LanguageID,
	)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Video,
		&i.DurationSeconds,
		&i.Position,
		&i.Description,
		&i.IsPublished,
		&i.CommentsCount,
		&i.AuthorID,
		&i.SeriesID,
		&i.SeriesPartID,
		&i.LanguageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementLectureCommentsCount = `-- name: DecrementLectureCommentsCount :exec
UPDATE "lectures" SET
  "comments_count" = "comments_count" - 1
WHERE "id" = $1
`

func (q *Queries) DecrementLectureCommentsCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, decrementLectureCommentsCount, id)
	return err
}

const decrementLecturePosition = `-- name: DecrementLecturePosition :exec
UPDATE "lectures" SET
  "position" = "position" - 1
WHERE 
    "series_part_id" = $1 AND 
    "position" > $2 AND 
    "position" <= $3
`

type DecrementLecturePositionParams struct {
	SeriesPartID int32
	Position     int16
	Position_2   int16
}

func (q *Queries) DecrementLecturePosition(ctx context.Context, arg DecrementLecturePositionParams) error {
	_, err := q.db.Exec(ctx, decrementLecturePosition, arg.SeriesPartID, arg.Position, arg.Position_2)
	return err
}

const findLectureById = `-- name: FindLectureById :one
SELECT id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at FROM "lectures"
WHERE "id" = $1 LIMIT 1
`

func (q *Queries) FindLectureById(ctx context.Context, id int32) (Lecture, error) {
	row := q.db.QueryRow(ctx, findLectureById, id)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Video,
		&i.DurationSeconds,
		&i.Position,
		&i.Description,
		&i.IsPublished,
		&i.CommentsCount,
		&i.AuthorID,
		&i.SeriesID,
		&i.SeriesPartID,
		&i.LanguageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLecturesBySeriesPartId = `-- name: FindLecturesBySeriesPartId :many
SELECT id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at FROM "lectures"
WHERE "series_part_id" = $1
ORDER BY "position" ASC
`

func (q *Queries) FindLecturesBySeriesPartId(ctx context.Context, seriesPartID int32) ([]Lecture, error) {
	rows, err := q.db.Query(ctx, findLecturesBySeriesPartId, seriesPartID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lecture{}
	for rows.Next() {
		var i Lecture
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Video,
			&i.DurationSeconds,
			&i.Position,
			&i.Description,
			&i.IsPublished,
			&i.CommentsCount,
			&i.AuthorID,
			&i.SeriesID,
			&i.SeriesPartID,
			&i.LanguageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedLecturesBySeriesPartId = `-- name: FindPaginatedLecturesBySeriesPartId :many
SELECT id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at FROM "lectures"
WHERE "series_part_id" = $1
ORDER BY "position" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedLecturesBySeriesPartIdParams struct {
	SeriesPartID int32
	Limit        int32
	Offset       int32
}

func (q *Queries) FindPaginatedLecturesBySeriesPartId(ctx context.Context, arg FindPaginatedLecturesBySeriesPartIdParams) ([]Lecture, error) {
	rows, err := q.db.Query(ctx, findPaginatedLecturesBySeriesPartId, arg.SeriesPartID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lecture{}
	for rows.Next() {
		var i Lecture
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Video,
			&i.DurationSeconds,
			&i.Position,
			&i.Description,
			&i.IsPublished,
			&i.CommentsCount,
			&i.AuthorID,
			&i.SeriesID,
			&i.SeriesPartID,
			&i.LanguageID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementLectureCommentsCount = `-- name: IncrementLectureCommentsCount :exec
UPDATE "lectures" SET
  "comments_count" = "comments_count" + 1
WHERE "id" = $1
`

func (q *Queries) IncrementLectureCommentsCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, incrementLectureCommentsCount, id)
	return err
}

const incrementLecturePosition = `-- name: IncrementLecturePosition :exec
UPDATE "lectures" SET
  "position" = "position" + 1
WHERE "series_part_id" = $1 AND "position" >= $2
`

type IncrementLecturePositionParams struct {
	SeriesPartID int32
	Position     int16
}

func (q *Queries) IncrementLecturePosition(ctx context.Context, arg IncrementLecturePositionParams) error {
	_, err := q.db.Exec(ctx, incrementLecturePosition, arg.SeriesPartID, arg.Position)
	return err
}

const updateLecture = `-- name: UpdateLecture :one
UPDATE "lectures" SET
  "title" = $1,
  "video" = $2,
  "duration_seconds" = $3,
  "description" = $4
WHERE "id" = $5
RETURNING id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at
`

type UpdateLectureParams struct {
	Title           string
	Video           string
	DurationSeconds int32
	Description     string
	ID              int32
}

func (q *Queries) UpdateLecture(ctx context.Context, arg UpdateLectureParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLecture,
		arg.Title,
		arg.Video,
		arg.DurationSeconds,
		arg.Description,
		arg.ID,
	)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Video,
		&i.DurationSeconds,
		&i.Position,
		&i.Description,
		&i.IsPublished,
		&i.CommentsCount,
		&i.AuthorID,
		&i.SeriesID,
		&i.SeriesPartID,
		&i.LanguageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLectureIsPublished = `-- name: UpdateLectureIsPublished :one
UPDATE "lectures" SET
  "is_published" = $1
WHERE "id" = $2
RETURNING id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at
`

type UpdateLectureIsPublishedParams struct {
	IsPublished bool
	ID          int32
}

func (q *Queries) UpdateLectureIsPublished(ctx context.Context, arg UpdateLectureIsPublishedParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLectureIsPublished, arg.IsPublished, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Video,
		&i.DurationSeconds,
		&i.Position,
		&i.Description,
		&i.IsPublished,
		&i.CommentsCount,
		&i.AuthorID,
		&i.SeriesID,
		&i.SeriesPartID,
		&i.LanguageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLecturePosition = `-- name: UpdateLecturePosition :one
UPDATE "lectures" SET
  "position" = $1
WHERE "id" = $2
RETURNING id, title, video, duration_seconds, position, description, is_published, comments_count, author_id, series_id, series_part_id, language_id, created_at, updated_at
`

type UpdateLecturePositionParams struct {
	Position int16
	ID       int32
}

func (q *Queries) UpdateLecturePosition(ctx context.Context, arg UpdateLecturePositionParams) (Lecture, error) {
	row := q.db.QueryRow(ctx, updateLecturePosition, arg.Position, arg.ID)
	var i Lecture
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Video,
		&i.DurationSeconds,
		&i.Position,
		&i.Description,
		&i.IsPublished,
		&i.CommentsCount,
		&i.AuthorID,
		&i.SeriesID,
		&i.SeriesPartID,
		&i.LanguageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
