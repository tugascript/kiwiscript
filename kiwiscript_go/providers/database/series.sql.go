// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: series.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSeriesReadTime = `-- name: AddSeriesReadTime :exec
UPDATE "series" SET
  "read_time_seconds" = "read_time_seconds" + $1,
  "updated_at" = now()
WHERE "slug" = $2
`

type AddSeriesReadTimeParams struct {
	ReadTimeSeconds int32
	Slug            string
}

func (q *Queries) AddSeriesReadTime(ctx context.Context, arg AddSeriesReadTimeParams) error {
	_, err := q.db.Exec(ctx, addSeriesReadTime, arg.ReadTimeSeconds, arg.Slug)
	return err
}

const addSeriesSectionsCount = `-- name: AddSeriesSectionsCount :exec
UPDATE "series" SET
  "sections_count" = "sections_count" + 1,
  "lessons_count" = "lessons_count" + $2,
  "watch_time_seconds" = "watch_time_seconds" + $3,
  "read_time_seconds" = "read_time_seconds" + $4,
  "updated_at" = now()
WHERE "slug" = $1
`

type AddSeriesSectionsCountParams struct {
	Slug             string
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) AddSeriesSectionsCount(ctx context.Context, arg AddSeriesSectionsCountParams) error {
	_, err := q.db.Exec(ctx, addSeriesSectionsCount,
		arg.Slug,
		arg.LessonsCount,
		arg.WatchTimeSeconds,
		arg.ReadTimeSeconds,
	)
	return err
}

const addSeriesWatchTime = `-- name: AddSeriesWatchTime :exec
UPDATE "series" SET
  "watch_time_seconds" = "watch_time_seconds" + $1,
  "updated_at" = now()
WHERE "slug" = $2
`

type AddSeriesWatchTimeParams struct {
	WatchTimeSeconds int32
	Slug             string
}

func (q *Queries) AddSeriesWatchTime(ctx context.Context, arg AddSeriesWatchTimeParams) error {
	_, err := q.db.Exec(ctx, addSeriesWatchTime, arg.WatchTimeSeconds, arg.Slug)
	return err
}

const countFilteredPublishedSeries = `-- name: CountFilteredPublishedSeries :one
SELECT COUNT("series"."id") FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
`

type CountFilteredPublishedSeriesParams struct {
	LanguageSlug string
	Title        string
}

func (q *Queries) CountFilteredPublishedSeries(ctx context.Context, arg CountFilteredPublishedSeriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilteredPublishedSeries, arg.LanguageSlug, arg.Title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilteredSeries = `-- name: CountFilteredSeries :one
SELECT COUNT("series"."id") FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
`

type CountFilteredSeriesParams struct {
	LanguageSlug string
	Title        string
}

func (q *Queries) CountFilteredSeries(ctx context.Context, arg CountFilteredSeriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilteredSeries, arg.LanguageSlug, arg.Title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedSeries = `-- name: CountPublishedSeries :one
SELECT COUNT("id") FROM "series"
WHERE
    "language_slug" = $1 AND
    "is_published" = true
`

func (q *Queries) CountPublishedSeries(ctx context.Context, languageSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishedSeries, languageSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT("id") FROM "series"
WHERE "language_slug" = $1
`

func (q *Queries) CountSeries(ctx context.Context, languageSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countSeries, languageSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeries = `-- name: CreateSeries :one

INSERT INTO "series" (
  "title",
  "slug",
  "description",
  "language_slug",
  "author_id"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) RETURNING id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type CreateSeriesParams struct {
	Title        string
	Slug         string
	Description  string
	LanguageSlug string
	AuthorID     int32
}

// Copyright (C) 2024 Afonso Barracha
//
// This file is part of KiwiScript.
//
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.
func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, createSeries,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.LanguageSlug,
		arg.AuthorID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementSeriesLessonsCount = `-- name: DecrementSeriesLessonsCount :exec
UPDATE "series" SET
  "lessons_count" = "lessons_count" - 1,
  "watch_time_seconds" = "watch_time_seconds" + $2,
  "read_time_seconds" = "read_time_seconds" + $3,
  "updated_at" = now()
WHERE "slug" = $1
`

type DecrementSeriesLessonsCountParams struct {
	Slug             string
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) DecrementSeriesLessonsCount(ctx context.Context, arg DecrementSeriesLessonsCountParams) error {
	_, err := q.db.Exec(ctx, decrementSeriesLessonsCount, arg.Slug, arg.WatchTimeSeconds, arg.ReadTimeSeconds)
	return err
}

const decrementSeriesSectionsCount = `-- name: DecrementSeriesSectionsCount :exec
UPDATE "series" SET
  "sections_count" = "sections_count" - 1,
  "lessons_count" = "lessons_count" - $2,
  "watch_time_seconds" = "watch_time_seconds" - $3,
  "read_time_seconds" = "read_time_seconds" - $4,
  "updated_at" = now()
WHERE "slug" = $1
`

type DecrementSeriesSectionsCountParams struct {
	Slug             string
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) DecrementSeriesSectionsCount(ctx context.Context, arg DecrementSeriesSectionsCountParams) error {
	_, err := q.db.Exec(ctx, decrementSeriesSectionsCount,
		arg.Slug,
		arg.LessonsCount,
		arg.WatchTimeSeconds,
		arg.ReadTimeSeconds,
	)
	return err
}

const deleteAllLanguageSeries = `-- name: DeleteAllLanguageSeries :exec
DELETE FROM "series"
WHERE "language_slug" = $1
`

func (q *Queries) DeleteAllLanguageSeries(ctx context.Context, languageSlug string) error {
	_, err := q.db.Exec(ctx, deleteAllLanguageSeries, languageSlug)
	return err
}

const deleteSeriesById = `-- name: DeleteSeriesById :exec
DELETE FROM "series"
WHERE "id" = $1
`

func (q *Queries) DeleteSeriesById(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSeriesById, id)
	return err
}

const findFilteredPublishedSeriesWithAuthorAndProgressSortByID = `-- name: FindFilteredPublishedSeriesWithAuthorAndProgressSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."completed_sections" AS "series_progress_completed_sections",
  "series_progress"."completed_lessons" AS "series_progress_completed_lessons",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $3 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."id" DESC
LIMIT $4 OFFSET $5
`

type FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDParams struct {
	UserID       int32
	Title        string
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow struct {
	ID                              int32
	Title                           string
	Slug                            string
	Description                     string
	SectionsCount                   int16
	LessonsCount                    int16
	WatchTimeSeconds                int32
	ReadTimeSeconds                 int32
	IsPublished                     bool
	LanguageSlug                    string
	AuthorID                        int32
	CreatedAt                       pgtype.Timestamp
	UpdatedAt                       pgtype.Timestamp
	AuthorFirstName                 string
	AuthorLastName                  string
	SeriesProgressID                pgtype.Int4
	SeriesProgressCompletedSections pgtype.Int2
	SeriesProgressCompletedLessons  pgtype.Int2
	PictureID                       pgtype.UUID
	PictureExt                      pgtype.Text
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorAndProgressSortByID(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDParams) ([]FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorAndProgressSortByID,
		arg.UserID,
		arg.Title,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressCompletedSections,
			&i.SeriesProgressCompletedLessons,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorAndProgressSortBySlug = `-- name: FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."completed_sections" AS "series_progress_completed_sections",
  "series_progress"."completed_lessons" AS "series_progress_completed_lessons",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
  "series"."language_slug" = $3 AND
  "series"."is_published" = true AND
  (
    "series"."title" ILIKE $2 OR
    "users"."first_name" ILIKE $2 OR
    "users"."last_name" ILIKE $2
  )
ORDER BY "series"."slug" ASC
LIMIT $4 OFFSET $5
`

type FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugParams struct {
	UserID       int32
	Title        string
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow struct {
	ID                              int32
	Title                           string
	Slug                            string
	Description                     string
	SectionsCount                   int16
	LessonsCount                    int16
	WatchTimeSeconds                int32
	ReadTimeSeconds                 int32
	IsPublished                     bool
	LanguageSlug                    string
	AuthorID                        int32
	CreatedAt                       pgtype.Timestamp
	UpdatedAt                       pgtype.Timestamp
	AuthorFirstName                 string
	AuthorLastName                  string
	SeriesProgressID                pgtype.Int4
	SeriesProgressCompletedSections pgtype.Int2
	SeriesProgressCompletedLessons  pgtype.Int2
	PictureID                       pgtype.UUID
	PictureExt                      pgtype.Text
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlug(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugParams) ([]FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorAndProgressSortBySlug,
		arg.UserID,
		arg.Title,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressCompletedSections,
			&i.SeriesProgressCompletedLessons,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorSortByID = `-- name: FindFilteredPublishedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindFilteredPublishedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorSortByID(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorSortByIDParams) ([]FindFilteredPublishedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorSortByID,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorSortBySlug = `-- name: FindFilteredPublishedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindFilteredPublishedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorSortBySlugParams) ([]FindFilteredPublishedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorSortBySlug,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredSeriesWithAuthorSortByID = `-- name: FindFilteredSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindFilteredSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindFilteredSeriesWithAuthorSortByID(ctx context.Context, arg FindFilteredSeriesWithAuthorSortByIDParams) ([]FindFilteredSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredSeriesWithAuthorSortByID,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindFilteredSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredSeriesWithAuthorSortBySlug = `-- name: FindFilteredSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindFilteredSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindFilteredSeriesWithAuthorSortBySlug(ctx context.Context, arg FindFilteredSeriesWithAuthorSortBySlugParams) ([]FindFilteredSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredSeriesWithAuthorSortBySlug,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorAndProgressSortByID = `-- name: FindPaginatedPublishedSeriesWithAuthorAndProgressSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."completed_sections" AS "series_progress_completed_sections",
  "series_progress"."completed_lessons" AS "series_progress_completed_lessons",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDParams struct {
	UserID       int32
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow struct {
	ID                              int32
	Title                           string
	Slug                            string
	Description                     string
	SectionsCount                   int16
	LessonsCount                    int16
	WatchTimeSeconds                int32
	ReadTimeSeconds                 int32
	IsPublished                     bool
	LanguageSlug                    string
	AuthorID                        int32
	CreatedAt                       pgtype.Timestamp
	UpdatedAt                       pgtype.Timestamp
	AuthorFirstName                 string
	AuthorLastName                  string
	SeriesProgressID                pgtype.Int4
	SeriesProgressCompletedSections pgtype.Int2
	SeriesProgressCompletedLessons  pgtype.Int2
	PictureID                       pgtype.UUID
	PictureExt                      pgtype.Text
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorAndProgressSortByID(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDParams) ([]FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorAndProgressSortByID,
		arg.UserID,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressCompletedSections,
			&i.SeriesProgressCompletedLessons,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug = `-- name: FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."completed_sections" AS "series_progress_completed_sections",
  "series_progress"."completed_lessons" AS "series_progress_completed_lessons",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugParams struct {
	UserID       int32
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow struct {
	ID                              int32
	Title                           string
	Slug                            string
	Description                     string
	SectionsCount                   int16
	LessonsCount                    int16
	WatchTimeSeconds                int32
	ReadTimeSeconds                 int32
	IsPublished                     bool
	LanguageSlug                    string
	AuthorID                        int32
	CreatedAt                       pgtype.Timestamp
	UpdatedAt                       pgtype.Timestamp
	AuthorFirstName                 string
	AuthorLastName                  string
	SeriesProgressID                pgtype.Int4
	SeriesProgressCompletedSections pgtype.Int2
	SeriesProgressCompletedLessons  pgtype.Int2
	PictureID                       pgtype.UUID
	PictureExt                      pgtype.Text
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugParams) ([]FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug,
		arg.UserID,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressCompletedSections,
			&i.SeriesProgressCompletedLessons,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorSortByID = `-- name: FindPaginatedPublishedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true
ORDER BY "series"."id" DESC
LIMIT $2 OFFSET $3
`

type FindPaginatedPublishedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorSortByID(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorSortByIDParams) ([]FindPaginatedPublishedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorSortByID, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorSortBySlug = `-- name: FindPaginatedPublishedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true
ORDER BY "series"."slug" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedPublishedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorSortBySlugParams) ([]FindPaginatedPublishedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorSortBySlug, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedSeriesWithAuthorSortByID = `-- name: FindPaginatedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE "series"."language_slug" = $1
ORDER BY "series"."id" DESC
LIMIT $2 OFFSET $3
`

type FindPaginatedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindPaginatedSeriesWithAuthorSortByID(ctx context.Context, arg FindPaginatedSeriesWithAuthorSortByIDParams) ([]FindPaginatedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedSeriesWithAuthorSortByID, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedSeriesWithAuthorSortBySlug = `-- name: FindPaginatedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE "series"."language_slug" = $1
ORDER BY "series"."slug" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindPaginatedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindPaginatedSeriesWithAuthorSortBySlugParams) ([]FindPaginatedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedSeriesWithAuthorSortBySlug, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.SectionsCount,
			&i.LessonsCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.PictureID,
			&i.PictureExt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPublishedSeriesBySlugAndLanguageSlug = `-- name: FindPublishedSeriesBySlugAndLanguageSlug :one
SELECT id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE
    "slug" = $1 AND
    "language_slug" = $2 AND
    "is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugAndLanguageSlugParams struct {
	Slug         string
	LanguageSlug string
}

func (q *Queries) FindPublishedSeriesBySlugAndLanguageSlug(ctx context.Context, arg FindPublishedSeriesBySlugAndLanguageSlugParams) (Series, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugAndLanguageSlug, arg.Slug, arg.LanguageSlug)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPublishedSeriesBySlugWithAuthorAndProgress = `-- name: FindPublishedSeriesBySlugWithAuthorAndProgress :one
SELECT
    series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
    "users"."first_name" AS "author_first_name",
    "users"."last_name" AS "author_last_name",
    "series_progress"."id" AS "series_progress_id",
    "series_progress"."completed_sections" AS "series_progress_completed_sections",
    "series_progress"."completed_lessons" AS "series_progress_completed_lessons",
    "series_pictures"."id" AS "picture_id",
    "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
    "series"."slug" = $2 AND
    "series"."language_slug" = $3 AND
    "series"."is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugWithAuthorAndProgressParams struct {
	UserID       int32
	Slug         string
	LanguageSlug string
}

type FindPublishedSeriesBySlugWithAuthorAndProgressRow struct {
	ID                              int32
	Title                           string
	Slug                            string
	Description                     string
	SectionsCount                   int16
	LessonsCount                    int16
	WatchTimeSeconds                int32
	ReadTimeSeconds                 int32
	IsPublished                     bool
	LanguageSlug                    string
	AuthorID                        int32
	CreatedAt                       pgtype.Timestamp
	UpdatedAt                       pgtype.Timestamp
	AuthorFirstName                 string
	AuthorLastName                  string
	SeriesProgressID                pgtype.Int4
	SeriesProgressCompletedSections pgtype.Int2
	SeriesProgressCompletedLessons  pgtype.Int2
	PictureID                       pgtype.UUID
	PictureExt                      pgtype.Text
}

func (q *Queries) FindPublishedSeriesBySlugWithAuthorAndProgress(ctx context.Context, arg FindPublishedSeriesBySlugWithAuthorAndProgressParams) (FindPublishedSeriesBySlugWithAuthorAndProgressRow, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugWithAuthorAndProgress, arg.UserID, arg.Slug, arg.LanguageSlug)
	var i FindPublishedSeriesBySlugWithAuthorAndProgressRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
		&i.SeriesProgressID,
		&i.SeriesProgressCompletedSections,
		&i.SeriesProgressCompletedLessons,
		&i.PictureID,
		&i.PictureExt,
	)
	return i, err
}

const findPublishedSeriesBySlugsWithAuthor = `-- name: FindPublishedSeriesBySlugsWithAuthor :one
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
  "series"."slug" = $1 AND
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugsWithAuthorParams struct {
	Slug         string
	LanguageSlug string
}

type FindPublishedSeriesBySlugsWithAuthorRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindPublishedSeriesBySlugsWithAuthor(ctx context.Context, arg FindPublishedSeriesBySlugsWithAuthorParams) (FindPublishedSeriesBySlugsWithAuthorRow, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugsWithAuthor, arg.Slug, arg.LanguageSlug)
	var i FindPublishedSeriesBySlugsWithAuthorRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
		&i.PictureID,
		&i.PictureExt,
	)
	return i, err
}

const findSeriesById = `-- name: FindSeriesById :one
SELECT id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE "id" = $1 LIMIT 1
`

func (q *Queries) FindSeriesById(ctx context.Context, id int32) (Series, error) {
	row := q.db.QueryRow(ctx, findSeriesById, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSeriesBySlugAndLanguageSlug = `-- name: FindSeriesBySlugAndLanguageSlug :one
SELECT id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE "slug" = $1 AND "language_slug" = $2
LIMIT 1
`

type FindSeriesBySlugAndLanguageSlugParams struct {
	Slug         string
	LanguageSlug string
}

func (q *Queries) FindSeriesBySlugAndLanguageSlug(ctx context.Context, arg FindSeriesBySlugAndLanguageSlugParams) (Series, error) {
	row := q.db.QueryRow(ctx, findSeriesBySlugAndLanguageSlug, arg.Slug, arg.LanguageSlug)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSeriesBySlugWithAuthor = `-- name: FindSeriesBySlugWithAuthor :one
SELECT
  series.id, series.title, series.slug, series.description, series.sections_count, series.lessons_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_pictures"."id" AS "picture_id",
  "series_pictures"."ext" AS "picture_ext"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_pictures" ON "series"."id" = "series_pictures"."series_id"
WHERE
  "series"."slug" = $1 AND
  "series"."language_slug" = $2
LIMIT 1
`

type FindSeriesBySlugWithAuthorParams struct {
	Slug         string
	LanguageSlug string
}

type FindSeriesBySlugWithAuthorRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	SectionsCount    int16
	LessonsCount     int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
	PictureID        pgtype.UUID
	PictureExt       pgtype.Text
}

func (q *Queries) FindSeriesBySlugWithAuthor(ctx context.Context, arg FindSeriesBySlugWithAuthorParams) (FindSeriesBySlugWithAuthorRow, error) {
	row := q.db.QueryRow(ctx, findSeriesBySlugWithAuthor, arg.Slug, arg.LanguageSlug)
	var i FindSeriesBySlugWithAuthorRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
		&i.PictureID,
		&i.PictureExt,
	)
	return i, err
}

const incrementSeriesLessonsCount = `-- name: IncrementSeriesLessonsCount :exec
UPDATE "series" SET
  "lessons_count" = "lessons_count" + 1,
  "watch_time_seconds" = "watch_time_seconds" + $2,
  "read_time_seconds" = "read_time_seconds" + $3,
  "updated_at" = now()
WHERE "slug" = $1
`

type IncrementSeriesLessonsCountParams struct {
	Slug             string
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) IncrementSeriesLessonsCount(ctx context.Context, arg IncrementSeriesLessonsCountParams) error {
	_, err := q.db.Exec(ctx, incrementSeriesLessonsCount, arg.Slug, arg.WatchTimeSeconds, arg.ReadTimeSeconds)
	return err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE "series" SET
  "title" = $1,
  "slug" = $2,
  "description" = $3,
  "updated_at" = now()
WHERE "id" = $4
RETURNING id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type UpdateSeriesParams struct {
	Title       string
	Slug        string
	Description string
	ID          int32
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeries,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeriesIsPublished = `-- name: UpdateSeriesIsPublished :one
UPDATE "series" SET
  "is_published" = $1,
  "updated_at" = now()
WHERE "id" = $2
RETURNING id, title, slug, description, sections_count, lessons_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type UpdateSeriesIsPublishedParams struct {
	IsPublished bool
	ID          int32
}

func (q *Queries) UpdateSeriesIsPublished(ctx context.Context, arg UpdateSeriesIsPublishedParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeriesIsPublished, arg.IsPublished, arg.ID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.SectionsCount,
		&i.LessonsCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
