// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: series.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addSeriesPartsCount = `-- name: AddSeriesPartsCount :exec
UPDATE "series" SET
  "series_parts_count" = "series_parts_count" + 1,
  "lectures_count" = "lectures_count" + $2,
  "watch_time_seconds" = "watch_time_seconds" + $3,
  "read_time_seconds" = "read_time_seconds" + $4,
  "updated_at" = now()
WHERE "slug" = $1
`

type AddSeriesPartsCountParams struct {
	Slug             string
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) AddSeriesPartsCount(ctx context.Context, arg AddSeriesPartsCountParams) error {
	_, err := q.db.Exec(ctx, addSeriesPartsCount,
		arg.Slug,
		arg.LecturesCount,
		arg.WatchTimeSeconds,
		arg.ReadTimeSeconds,
	)
	return err
}

const addSeriesReadTime = `-- name: AddSeriesReadTime :exec
UPDATE "series" SET
  "read_time_seconds" = "read_time_seconds" + $1,
  "updated_at" = now()
WHERE "slug" = $2
`

type AddSeriesReadTimeParams struct {
	ReadTimeSeconds int32
	Slug            string
}

func (q *Queries) AddSeriesReadTime(ctx context.Context, arg AddSeriesReadTimeParams) error {
	_, err := q.db.Exec(ctx, addSeriesReadTime, arg.ReadTimeSeconds, arg.Slug)
	return err
}

const addSeriesWatchTime = `-- name: AddSeriesWatchTime :exec
UPDATE "series" SET
  "watch_time_seconds" = "watch_time_seconds" + $1,
  "updated_at" = now()
WHERE "slug" = $2
`

type AddSeriesWatchTimeParams struct {
	WatchTimeSeconds int32
	Slug             string
}

func (q *Queries) AddSeriesWatchTime(ctx context.Context, arg AddSeriesWatchTimeParams) error {
	_, err := q.db.Exec(ctx, addSeriesWatchTime, arg.WatchTimeSeconds, arg.Slug)
	return err
}

const countFilteredPublishedSeries = `-- name: CountFilteredPublishedSeries :one
SELECT COUNT("series"."id") FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
`

type CountFilteredPublishedSeriesParams struct {
	LanguageSlug string
	Title        string
}

func (q *Queries) CountFilteredPublishedSeries(ctx context.Context, arg CountFilteredPublishedSeriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilteredPublishedSeries, arg.LanguageSlug, arg.Title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFilteredSeries = `-- name: CountFilteredSeries :one
SELECT COUNT("series"."id") FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
`

type CountFilteredSeriesParams struct {
	LanguageSlug string
	Title        string
}

func (q *Queries) CountFilteredSeries(ctx context.Context, arg CountFilteredSeriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFilteredSeries, arg.LanguageSlug, arg.Title)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedSeries = `-- name: CountPublishedSeries :one
SELECT COUNT("id") FROM "series"
WHERE
    "language_slug" = $1 AND
    "is_published" = true
`

func (q *Queries) CountPublishedSeries(ctx context.Context, languageSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishedSeries, languageSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSeries = `-- name: CountSeries :one
SELECT COUNT("id") FROM "series"
WHERE "language_slug" = $1
`

func (q *Queries) CountSeries(ctx context.Context, languageSlug string) (int64, error) {
	row := q.db.QueryRow(ctx, countSeries, languageSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSeries = `-- name: CreateSeries :one

INSERT INTO "series" (
  "title",
  "slug",
  "description",
  "language_slug",
  "author_id"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) RETURNING id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type CreateSeriesParams struct {
	Title        string
	Slug         string
	Description  string
	LanguageSlug string
	AuthorID     int32
}

// Copyright (C) 2024 Afonso Barracha
//
// This file is part of KiwiScript.
//
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.
func (q *Queries) CreateSeries(ctx context.Context, arg CreateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, createSeries,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.LanguageSlug,
		arg.AuthorID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementSeriesLecturesCount = `-- name: DecrementSeriesLecturesCount :exec
UPDATE "series" SET
  "lectures_count" = "lectures_count" - 1,
  "watch_time_seconds" = "watch_time_seconds" + $2,
  "read_time_seconds" = "read_time_seconds" + $3,
  "updated_at" = now()
WHERE "slug" = $1
`

type DecrementSeriesLecturesCountParams struct {
	Slug             string
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) DecrementSeriesLecturesCount(ctx context.Context, arg DecrementSeriesLecturesCountParams) error {
	_, err := q.db.Exec(ctx, decrementSeriesLecturesCount, arg.Slug, arg.WatchTimeSeconds, arg.ReadTimeSeconds)
	return err
}

const decrementSeriesPartsCount = `-- name: DecrementSeriesPartsCount :exec
UPDATE "series" SET
  "series_parts_count" = "series_parts_count" - 1,
  "lectures_count" = "lectures_count" - $2,
  "watch_time_seconds" = "watch_time_seconds" - $3,
  "read_time_seconds" = "read_time_seconds" - $4,
  "updated_at" = now()
WHERE "slug" = $1
`

type DecrementSeriesPartsCountParams struct {
	Slug             string
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) DecrementSeriesPartsCount(ctx context.Context, arg DecrementSeriesPartsCountParams) error {
	_, err := q.db.Exec(ctx, decrementSeriesPartsCount,
		arg.Slug,
		arg.LecturesCount,
		arg.WatchTimeSeconds,
		arg.ReadTimeSeconds,
	)
	return err
}

const deleteSeriesById = `-- name: DeleteSeriesById :exec
DELETE FROM "series"
WHERE "id" = $1
`

func (q *Queries) DeleteSeriesById(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteSeriesById, id)
	return err
}

const findFilteredPublishedSeriesWithAuthorAndProgressSortByID = `-- name: FindFilteredPublishedSeriesWithAuthorAndProgressSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."is_current" AS "series_progress_is_current",
  "series_progress"."completed_parts" AS "series_progress_completed_parts",
  "series_progress"."in_progress_parts" AS "series_progress_in_progress_parts",
  "series_progress"."completed_lectures" AS "series_progress_completed_lectures",
  "series_progress"."in_progress_lectures" AS "series_progress_in_progress_lectures"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
)
WHERE
  "series"."language_slug" = $3 AND
  "series"."is_published" = true
ORDER BY "series"."id" DESC
LIMIT $4 OFFSET $5
`

type FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDParams struct {
	UserID       int32
	Title        string
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow struct {
	ID                               int32
	Title                            string
	Slug                             string
	Description                      string
	PartsCount                       int16
	LecturesCount                    int16
	WatchTimeSeconds                 int32
	ReadTimeSeconds                  int32
	IsPublished                      bool
	LanguageSlug                     string
	AuthorID                         int32
	CreatedAt                        pgtype.Timestamp
	UpdatedAt                        pgtype.Timestamp
	AuthorFirstName                  string
	AuthorLastName                   string
	SeriesProgressID                 pgtype.Int4
	SeriesProgressIsCurrent          pgtype.Bool
	SeriesProgressCompletedParts     pgtype.Int2
	SeriesProgressInProgressParts    pgtype.Int2
	SeriesProgressCompletedLectures  pgtype.Int2
	SeriesProgressInProgressLectures pgtype.Int2
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorAndProgressSortByID(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDParams) ([]FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorAndProgressSortByID,
		arg.UserID,
		arg.Title,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorAndProgressSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressIsCurrent,
			&i.SeriesProgressCompletedParts,
			&i.SeriesProgressInProgressParts,
			&i.SeriesProgressCompletedLectures,
			&i.SeriesProgressInProgressLectures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorAndProgressSortBySlug = `-- name: FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."is_current" AS "series_progress_is_current",
  "series_progress"."completed_parts" AS "series_progress_completed_parts",
  "series_progress"."in_progress_parts" AS "series_progress_in_progress_parts",
  "series_progress"."completed_lectures" AS "series_progress_completed_lectures",
  "series_progress"."in_progress_lectures" AS "series_progress_in_progress_lectures"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
)
WHERE
  "series"."language_slug" = $3 AND
  "series"."is_published" = true
ORDER BY "series"."slug" ASC
LIMIT $4 OFFSET $5
`

type FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugParams struct {
	UserID       int32
	Title        string
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow struct {
	ID                               int32
	Title                            string
	Slug                             string
	Description                      string
	PartsCount                       int16
	LecturesCount                    int16
	WatchTimeSeconds                 int32
	ReadTimeSeconds                  int32
	IsPublished                      bool
	LanguageSlug                     string
	AuthorID                         int32
	CreatedAt                        pgtype.Timestamp
	UpdatedAt                        pgtype.Timestamp
	AuthorFirstName                  string
	AuthorLastName                   string
	SeriesProgressID                 pgtype.Int4
	SeriesProgressIsCurrent          pgtype.Bool
	SeriesProgressCompletedParts     pgtype.Int2
	SeriesProgressInProgressParts    pgtype.Int2
	SeriesProgressCompletedLectures  pgtype.Int2
	SeriesProgressInProgressLectures pgtype.Int2
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlug(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugParams) ([]FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorAndProgressSortBySlug,
		arg.UserID,
		arg.Title,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorAndProgressSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressIsCurrent,
			&i.SeriesProgressCompletedParts,
			&i.SeriesProgressInProgressParts,
			&i.SeriesProgressCompletedLectures,
			&i.SeriesProgressInProgressLectures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorSortByID = `-- name: FindFilteredPublishedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindFilteredPublishedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorSortByID(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorSortByIDParams) ([]FindFilteredPublishedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorSortByID,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredPublishedSeriesWithAuthorSortBySlug = `-- name: FindFilteredPublishedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindFilteredPublishedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredPublishedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindFilteredPublishedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindFilteredPublishedSeriesWithAuthorSortBySlugParams) ([]FindFilteredPublishedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredPublishedSeriesWithAuthorSortBySlug,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredPublishedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredPublishedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredSeriesWithAuthorSortByID = `-- name: FindFilteredSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindFilteredSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindFilteredSeriesWithAuthorSortByID(ctx context.Context, arg FindFilteredSeriesWithAuthorSortByIDParams) ([]FindFilteredSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findFilteredSeriesWithAuthorSortByID,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindFilteredSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findFilteredSeriesWithAuthorSortBySlug = `-- name: FindFilteredSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    (
        "series"."title" ILIKE $2 OR
        "users"."first_name" ILIKE $2 OR
        "users"."last_name" ILIKE $2
    )
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindFilteredSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Title        string
	Limit        int32
	Offset       int32
}

type FindFilteredSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindFilteredSeriesWithAuthorSortBySlug(ctx context.Context, arg FindFilteredSeriesWithAuthorSortBySlugParams) ([]FindFilteredSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findFilteredSeriesWithAuthorSortBySlug,
		arg.LanguageSlug,
		arg.Title,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindFilteredSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindFilteredSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorAndProgressSortByID = `-- name: FindPaginatedPublishedSeriesWithAuthorAndProgressSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."is_current" AS "series_progress_is_current",
  "series_progress"."completed_parts" AS "series_progress_completed_parts",
  "series_progress"."in_progress_parts" AS "series_progress_in_progress_parts",
  "series_progress"."completed_lectures" AS "series_progress_completed_lectures",
  "series_progress"."in_progress_lectures" AS "series_progress_in_progress_lectures"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
WHERE
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
ORDER BY "series"."id" DESC
LIMIT $3 OFFSET $4
`

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDParams struct {
	UserID       int32
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow struct {
	ID                               int32
	Title                            string
	Slug                             string
	Description                      string
	PartsCount                       int16
	LecturesCount                    int16
	WatchTimeSeconds                 int32
	ReadTimeSeconds                  int32
	IsPublished                      bool
	LanguageSlug                     string
	AuthorID                         int32
	CreatedAt                        pgtype.Timestamp
	UpdatedAt                        pgtype.Timestamp
	AuthorFirstName                  string
	AuthorLastName                   string
	SeriesProgressID                 pgtype.Int4
	SeriesProgressIsCurrent          pgtype.Bool
	SeriesProgressCompletedParts     pgtype.Int2
	SeriesProgressInProgressParts    pgtype.Int2
	SeriesProgressCompletedLectures  pgtype.Int2
	SeriesProgressInProgressLectures pgtype.Int2
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorAndProgressSortByID(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDParams) ([]FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorAndProgressSortByID,
		arg.UserID,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorAndProgressSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressIsCurrent,
			&i.SeriesProgressCompletedParts,
			&i.SeriesProgressInProgressParts,
			&i.SeriesProgressCompletedLectures,
			&i.SeriesProgressInProgressLectures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug = `-- name: FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name",
  "series_progress"."id" AS "series_progress_id",
  "series_progress"."is_current" AS "series_progress_is_current",
  "series_progress"."completed_parts" AS "series_progress_completed_parts",
  "series_progress"."in_progress_parts" AS "series_progress_in_progress_parts",
  "series_progress"."completed_lectures" AS "series_progress_completed_lectures",
  "series_progress"."in_progress_lectures" AS "series_progress_in_progress_lectures"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
WHERE
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
ORDER BY "series"."slug" ASC
LIMIT $3 OFFSET $4
`

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugParams struct {
	UserID       int32
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow struct {
	ID                               int32
	Title                            string
	Slug                             string
	Description                      string
	PartsCount                       int16
	LecturesCount                    int16
	WatchTimeSeconds                 int32
	ReadTimeSeconds                  int32
	IsPublished                      bool
	LanguageSlug                     string
	AuthorID                         int32
	CreatedAt                        pgtype.Timestamp
	UpdatedAt                        pgtype.Timestamp
	AuthorFirstName                  string
	AuthorLastName                   string
	SeriesProgressID                 pgtype.Int4
	SeriesProgressIsCurrent          pgtype.Bool
	SeriesProgressCompletedParts     pgtype.Int2
	SeriesProgressInProgressParts    pgtype.Int2
	SeriesProgressCompletedLectures  pgtype.Int2
	SeriesProgressInProgressLectures pgtype.Int2
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugParams) ([]FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorAndProgressSortBySlug,
		arg.UserID,
		arg.LanguageSlug,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorAndProgressSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.SeriesProgressID,
			&i.SeriesProgressIsCurrent,
			&i.SeriesProgressCompletedParts,
			&i.SeriesProgressInProgressParts,
			&i.SeriesProgressCompletedLectures,
			&i.SeriesProgressInProgressLectures,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorSortByID = `-- name: FindPaginatedPublishedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true
ORDER BY "series"."id" DESC
LIMIT $2 OFFSET $3
`

type FindPaginatedPublishedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorSortByID(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorSortByIDParams) ([]FindPaginatedPublishedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorSortByID, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedSeriesWithAuthorSortBySlug = `-- name: FindPaginatedPublishedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
    "series"."language_slug" = $1 AND
    "series"."is_published" = true
ORDER BY "series"."slug" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedPublishedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindPaginatedPublishedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindPaginatedPublishedSeriesWithAuthorSortBySlugParams) ([]FindPaginatedPublishedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedSeriesWithAuthorSortBySlug, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedPublishedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedSeriesWithAuthorSortByID = `-- name: FindPaginatedSeriesWithAuthorSortByID :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE "series"."language_slug" = $1
ORDER BY "series"."id" DESC
LIMIT $2 OFFSET $3
`

type FindPaginatedSeriesWithAuthorSortByIDParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedSeriesWithAuthorSortByIDRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindPaginatedSeriesWithAuthorSortByID(ctx context.Context, arg FindPaginatedSeriesWithAuthorSortByIDParams) ([]FindPaginatedSeriesWithAuthorSortByIDRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedSeriesWithAuthorSortByID, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedSeriesWithAuthorSortByIDRow{}
	for rows.Next() {
		var i FindPaginatedSeriesWithAuthorSortByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedSeriesWithAuthorSortBySlug = `-- name: FindPaginatedSeriesWithAuthorSortBySlug :many
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE "series"."language_slug" = $1
ORDER BY "series"."slug" ASC
LIMIT $2 OFFSET $3
`

type FindPaginatedSeriesWithAuthorSortBySlugParams struct {
	LanguageSlug string
	Limit        int32
	Offset       int32
}

type FindPaginatedSeriesWithAuthorSortBySlugRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindPaginatedSeriesWithAuthorSortBySlug(ctx context.Context, arg FindPaginatedSeriesWithAuthorSortBySlugParams) ([]FindPaginatedSeriesWithAuthorSortBySlugRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedSeriesWithAuthorSortBySlug, arg.LanguageSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedSeriesWithAuthorSortBySlugRow{}
	for rows.Next() {
		var i FindPaginatedSeriesWithAuthorSortBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.PartsCount,
			&i.LecturesCount,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.IsPublished,
			&i.LanguageSlug,
			&i.AuthorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorFirstName,
			&i.AuthorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPublishedSeriesBySlugAndLanguageSlug = `-- name: FindPublishedSeriesBySlugAndLanguageSlug :one
SELECT id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE
    "slug" = $1 AND
    "language_slug" = $2 AND
    "is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugAndLanguageSlugParams struct {
	Slug         string
	LanguageSlug string
}

func (q *Queries) FindPublishedSeriesBySlugAndLanguageSlug(ctx context.Context, arg FindPublishedSeriesBySlugAndLanguageSlugParams) (Series, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugAndLanguageSlug, arg.Slug, arg.LanguageSlug)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPublishedSeriesBySlugWithAuthorAndProgress = `-- name: FindPublishedSeriesBySlugWithAuthorAndProgress :one
SELECT
    series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
    "users"."first_name" AS "author_first_name",
    "users"."last_name" AS "author_last_name",
    "series_progress"."id" AS "series_progress_id",
    "series_progress"."is_current" AS "series_progress_is_current",
    "series_progress"."completed_parts" AS "series_progress_completed_parts",
    "series_progress"."in_progress_parts" AS "series_progress_in_progress_parts",
    "series_progress"."completed_lectures" AS "series_progress_completed_lectures",
    "series_progress"."in_progress_lectures" AS "series_progress_in_progress_lectures"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
LEFT JOIN "series_progress" ON (
    "series"."slug" = "series_progress"."series_slug" AND
    "series_progress"."user_id" = $1
)
WHERE
    "series"."slug" = $2 AND
    "series"."language_slug" = $3 AND
    "series"."is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugWithAuthorAndProgressParams struct {
	UserID       int32
	Slug         string
	LanguageSlug string
}

type FindPublishedSeriesBySlugWithAuthorAndProgressRow struct {
	ID                               int32
	Title                            string
	Slug                             string
	Description                      string
	PartsCount                       int16
	LecturesCount                    int16
	WatchTimeSeconds                 int32
	ReadTimeSeconds                  int32
	IsPublished                      bool
	LanguageSlug                     string
	AuthorID                         int32
	CreatedAt                        pgtype.Timestamp
	UpdatedAt                        pgtype.Timestamp
	AuthorFirstName                  string
	AuthorLastName                   string
	SeriesProgressID                 pgtype.Int4
	SeriesProgressIsCurrent          pgtype.Bool
	SeriesProgressCompletedParts     pgtype.Int2
	SeriesProgressInProgressParts    pgtype.Int2
	SeriesProgressCompletedLectures  pgtype.Int2
	SeriesProgressInProgressLectures pgtype.Int2
}

func (q *Queries) FindPublishedSeriesBySlugWithAuthorAndProgress(ctx context.Context, arg FindPublishedSeriesBySlugWithAuthorAndProgressParams) (FindPublishedSeriesBySlugWithAuthorAndProgressRow, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugWithAuthorAndProgress, arg.UserID, arg.Slug, arg.LanguageSlug)
	var i FindPublishedSeriesBySlugWithAuthorAndProgressRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
		&i.SeriesProgressID,
		&i.SeriesProgressIsCurrent,
		&i.SeriesProgressCompletedParts,
		&i.SeriesProgressInProgressParts,
		&i.SeriesProgressCompletedLectures,
		&i.SeriesProgressInProgressLectures,
	)
	return i, err
}

const findPublishedSeriesBySlugsWithAuthor = `-- name: FindPublishedSeriesBySlugsWithAuthor :one
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
  "series"."slug" = $1 AND
  "series"."language_slug" = $2 AND
  "series"."is_published" = true
LIMIT 1
`

type FindPublishedSeriesBySlugsWithAuthorParams struct {
	Slug         string
	LanguageSlug string
}

type FindPublishedSeriesBySlugsWithAuthorRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindPublishedSeriesBySlugsWithAuthor(ctx context.Context, arg FindPublishedSeriesBySlugsWithAuthorParams) (FindPublishedSeriesBySlugsWithAuthorRow, error) {
	row := q.db.QueryRow(ctx, findPublishedSeriesBySlugsWithAuthor, arg.Slug, arg.LanguageSlug)
	var i FindPublishedSeriesBySlugsWithAuthorRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
	)
	return i, err
}

const findSeriesById = `-- name: FindSeriesById :one
SELECT id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE "id" = $1 LIMIT 1
`

func (q *Queries) FindSeriesById(ctx context.Context, id int32) (Series, error) {
	row := q.db.QueryRow(ctx, findSeriesById, id)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSeriesBySlugAndLanguageSlug = `-- name: FindSeriesBySlugAndLanguageSlug :one
SELECT id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at FROM "series"
WHERE "slug" = $1 AND "language_slug" = $2
LIMIT 1
`

type FindSeriesBySlugAndLanguageSlugParams struct {
	Slug         string
	LanguageSlug string
}

func (q *Queries) FindSeriesBySlugAndLanguageSlug(ctx context.Context, arg FindSeriesBySlugAndLanguageSlugParams) (Series, error) {
	row := q.db.QueryRow(ctx, findSeriesBySlugAndLanguageSlug, arg.Slug, arg.LanguageSlug)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSeriesBySlugWithAuthor = `-- name: FindSeriesBySlugWithAuthor :one
SELECT
  series.id, series.title, series.slug, series.description, series.parts_count, series.lectures_count, series.watch_time_seconds, series.read_time_seconds, series.is_published, series.language_slug, series.author_id, series.created_at, series.updated_at,
  "users"."first_name" AS "author_first_name",
  "users"."last_name" AS "author_last_name"
FROM "series"
INNER JOIN "users" ON "series"."author_id" = "users"."id"
WHERE
  "series"."slug" = $1 AND
  "series"."language_slug" = $2
LIMIT 1
`

type FindSeriesBySlugWithAuthorParams struct {
	Slug         string
	LanguageSlug string
}

type FindSeriesBySlugWithAuthorRow struct {
	ID               int32
	Title            string
	Slug             string
	Description      string
	PartsCount       int16
	LecturesCount    int16
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
	IsPublished      bool
	LanguageSlug     string
	AuthorID         int32
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	AuthorFirstName  string
	AuthorLastName   string
}

func (q *Queries) FindSeriesBySlugWithAuthor(ctx context.Context, arg FindSeriesBySlugWithAuthorParams) (FindSeriesBySlugWithAuthorRow, error) {
	row := q.db.QueryRow(ctx, findSeriesBySlugWithAuthor, arg.Slug, arg.LanguageSlug)
	var i FindSeriesBySlugWithAuthorRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuthorFirstName,
		&i.AuthorLastName,
	)
	return i, err
}

const incrementSeriesLecturesCount = `-- name: IncrementSeriesLecturesCount :exec
UPDATE "series" SET
  "lectures_count" = "lectures_count" + 1,
  "watch_time_seconds" = "watch_time_seconds" + $2,
  "read_time_seconds" = "read_time_seconds" + $3,
  "updated_at" = now()
WHERE "slug" = $1
`

type IncrementSeriesLecturesCountParams struct {
	Slug             string
	WatchTimeSeconds int32
	ReadTimeSeconds  int32
}

func (q *Queries) IncrementSeriesLecturesCount(ctx context.Context, arg IncrementSeriesLecturesCountParams) error {
	_, err := q.db.Exec(ctx, incrementSeriesLecturesCount, arg.Slug, arg.WatchTimeSeconds, arg.ReadTimeSeconds)
	return err
}

const updateSeries = `-- name: UpdateSeries :one
UPDATE "series" SET
  "title" = $1,
  "slug" = $2,
  "description" = $3,
  "updated_at" = now()
WHERE "id" = $4
RETURNING id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type UpdateSeriesParams struct {
	Title       string
	Slug        string
	Description string
	ID          int32
}

func (q *Queries) UpdateSeries(ctx context.Context, arg UpdateSeriesParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeries,
		arg.Title,
		arg.Slug,
		arg.Description,
		arg.ID,
	)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeriesIsPublished = `-- name: UpdateSeriesIsPublished :one
UPDATE "series" SET
  "is_published" = $1,
  "updated_at" = now()
WHERE "id" = $2
RETURNING id, title, slug, description, parts_count, lectures_count, watch_time_seconds, read_time_seconds, is_published, language_slug, author_id, created_at, updated_at
`

type UpdateSeriesIsPublishedParams struct {
	IsPublished bool
	ID          int32
}

func (q *Queries) UpdateSeriesIsPublished(ctx context.Context, arg UpdateSeriesIsPublishedParams) (Series, error) {
	row := q.db.QueryRow(ctx, updateSeriesIsPublished, arg.IsPublished, arg.ID)
	var i Series
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Slug,
		&i.Description,
		&i.PartsCount,
		&i.LecturesCount,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.IsPublished,
		&i.LanguageSlug,
		&i.AuthorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
