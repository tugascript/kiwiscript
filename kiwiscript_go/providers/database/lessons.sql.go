// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: lessons.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countLessonsBySectionID = `-- name: CountLessonsBySectionID :one
SELECT COUNT("id") FROM "lessons"
WHERE "section_id" = $1
LIMIT 1
`

func (q *Queries) CountLessonsBySectionID(ctx context.Context, sectionID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countLessonsBySectionID, sectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPublishedLessonsBySectionID = `-- name: CountPublishedLessonsBySectionID :one
SELECT COUNT("id") FROM "lessons"
WHERE "section_id" = $1 AND "is_published" = true
LIMIT 1
`

func (q *Queries) CountPublishedLessonsBySectionID(ctx context.Context, sectionID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countPublishedLessonsBySectionID, sectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLesson = `-- name: CreateLesson :one

INSERT INTO "lessons" (
  "title",
  "author_id",
  "section_id",
  "language_slug",
  "series_slug",
  "position"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  (
    SELECT COUNT("id") + 1 FROM "lessons"
    WHERE "section_id" = $3
  )
) RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at
`

type CreateLessonParams struct {
	Title        string
	AuthorID     int32
	SectionID    int32
	LanguageSlug string
	SeriesSlug   string
}

// Copyright (C) 2024 Afonso Barracha
//
// This file is part of KiwiScript.
//
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.
func (q *Queries) CreateLesson(ctx context.Context, arg CreateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, createLesson,
		arg.Title,
		arg.AuthorID,
		arg.SectionID,
		arg.LanguageSlug,
		arg.SeriesSlug,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const decrementLessonPosition = `-- name: DecrementLessonPosition :exec
UPDATE "lessons" SET
  "position" = "position" - 1
WHERE 
    "section_id" = $1 AND
    "position" > $2 AND 
    "position" <= $3
`

type DecrementLessonPositionParams struct {
	SectionID  int32
	Position   int16
	Position_2 int16
}

func (q *Queries) DecrementLessonPosition(ctx context.Context, arg DecrementLessonPositionParams) error {
	_, err := q.db.Exec(ctx, decrementLessonPosition, arg.SectionID, arg.Position, arg.Position_2)
	return err
}

const deleteLessonByID = `-- name: DeleteLessonByID :exec
DELETE FROM "lessons"
WHERE "id" = $1
`

func (q *Queries) DeleteLessonByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteLessonByID, id)
	return err
}

const findLessonBySlugsAndIDs = `-- name: FindLessonBySlugsAndIDs :one
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at FROM "lessons"
WHERE
  "language_slug" = $1 AND
  "series_slug" = $2 AND
  "section_id" = $3 AND
  "id" = $4
LIMIT 1
`

type FindLessonBySlugsAndIDsParams struct {
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	ID           int32
}

func (q *Queries) FindLessonBySlugsAndIDs(ctx context.Context, arg FindLessonBySlugsAndIDsParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, findLessonBySlugsAndIDs,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.ID,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findLessonBySlugsAndIDsWithArticleAndVideo = `-- name: FindLessonBySlugsAndIDsWithArticleAndVideo :one
SELECT
    lessons.id, lessons.title, lessons.position, lessons.is_published, lessons.watch_time_seconds, lessons.read_time_seconds, lessons.author_id, lessons.language_slug, lessons.series_slug, lessons.section_id, lessons.created_at, lessons.updated_at,
    "lesson_articles"."id" AS "lesson_acticle_id",
    "lesson_articles"."content" AS "lesson_article_content",
    "lesson_videos"."id" AS "lesson_video_id",
    "lesson_videos"."url" AS "lesson_video_url"
FROM "lessons"
LEFT JOIN "lesson_articles" ON "lessons"."id" = "lesson_articles"."lesson_id"
LEFT JOIN "lesson_videos" ON "lessons"."id" = "lesson_videos"."lesson_id"
WHERE
    "lessons"."language_slug" = $1 AND
    "lessons"."series_slug" = $2 AND
    "lessons"."section_id" = $3 AND
    "lessons"."id" = $4
LIMIT 1
`

type FindLessonBySlugsAndIDsWithArticleAndVideoParams struct {
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	ID           int32
}

type FindLessonBySlugsAndIDsWithArticleAndVideoRow struct {
	ID                   int32
	Title                string
	Position             int16
	IsPublished          bool
	WatchTimeSeconds     int32
	ReadTimeSeconds      int32
	AuthorID             int32
	LanguageSlug         string
	SeriesSlug           string
	SectionID            int32
	CreatedAt            pgtype.Timestamp
	UpdatedAt            pgtype.Timestamp
	LessonActicleID      pgtype.Int4
	LessonArticleContent pgtype.Text
	LessonVideoID        pgtype.Int4
	LessonVideoUrl       pgtype.Text
}

func (q *Queries) FindLessonBySlugsAndIDsWithArticleAndVideo(ctx context.Context, arg FindLessonBySlugsAndIDsWithArticleAndVideoParams) (FindLessonBySlugsAndIDsWithArticleAndVideoRow, error) {
	row := q.db.QueryRow(ctx, findLessonBySlugsAndIDsWithArticleAndVideo,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.ID,
	)
	var i FindLessonBySlugsAndIDsWithArticleAndVideoRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LessonActicleID,
		&i.LessonArticleContent,
		&i.LessonVideoID,
		&i.LessonVideoUrl,
	)
	return i, err
}

const findLessonsBySectionID = `-- name: FindLessonsBySectionID :many
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at FROM "lessons"
WHERE "section_id" = $1
ORDER BY "position" ASC
`

func (q *Queries) FindLessonsBySectionID(ctx context.Context, sectionID int32) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, findLessonsBySectionID, sectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lesson{}
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SectionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedLessonsBySlugsAndSectionID = `-- name: FindPaginatedLessonsBySlugsAndSectionID :many
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at FROM "lessons"
WHERE
  "language_slug" = $1 AND
  "series_slug" = $2 AND
  "section_id" = $3
ORDER BY "position" ASC
LIMIT $4 OFFSET $5
`

type FindPaginatedLessonsBySlugsAndSectionIDParams struct {
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	Limit        int32
	Offset       int32
}

func (q *Queries) FindPaginatedLessonsBySlugsAndSectionID(ctx context.Context, arg FindPaginatedLessonsBySlugsAndSectionIDParams) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, findPaginatedLessonsBySlugsAndSectionID,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lesson{}
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SectionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedLessonsBySlugsAndSectionID = `-- name: FindPaginatedPublishedLessonsBySlugsAndSectionID :many
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at FROM "lessons"
WHERE
    "language_slug" = $1 AND
    "series_slug" = $2 AND
    "section_id" = $3 AND
    "is_published" = true
ORDER BY "position" ASC
LIMIT $4 OFFSET $5
`

type FindPaginatedPublishedLessonsBySlugsAndSectionIDParams struct {
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	Limit        int32
	Offset       int32
}

func (q *Queries) FindPaginatedPublishedLessonsBySlugsAndSectionID(ctx context.Context, arg FindPaginatedPublishedLessonsBySlugsAndSectionIDParams) ([]Lesson, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedLessonsBySlugsAndSectionID,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lesson{}
	for rows.Next() {
		var i Lesson
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SectionID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPaginatedPublishedLessonsBySlugsAndSectionIDWithProgress = `-- name: FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgress :many
SELECT
    lessons.id, lessons.title, lessons.position, lessons.is_published, lessons.watch_time_seconds, lessons.read_time_seconds, lessons.author_id, lessons.language_slug, lessons.series_slug, lessons.section_id, lessons.created_at, lessons.updated_at,
    "lesson_progress"."completed_at" AS "lesson_progress_completed_at"
FROM "lessons"
LEFT JOIN "lesson_progress" ON (
    "lessons"."id" = "lesson_progress"."lesson_id" AND
    "lesson_progress"."user_id" = $1
)
WHERE
    "lessons"."language_slug" = $2 AND
    "lessons"."series_slug" = $3 AND
    "lessons"."section_id" = $4 AND
    "lessons"."is_published" = true
ORDER BY "lessons"."position" ASC
LIMIT $5 OFFSET $6
`

type FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressParams struct {
	UserID       int32
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	Limit        int32
	Offset       int32
}

type FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressRow struct {
	ID                        int32
	Title                     string
	Position                  int16
	IsPublished               bool
	WatchTimeSeconds          int32
	ReadTimeSeconds           int32
	AuthorID                  int32
	LanguageSlug              string
	SeriesSlug                string
	SectionID                 int32
	CreatedAt                 pgtype.Timestamp
	UpdatedAt                 pgtype.Timestamp
	LessonProgressCompletedAt pgtype.Timestamp
}

func (q *Queries) FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgress(ctx context.Context, arg FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressParams) ([]FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressRow, error) {
	rows, err := q.db.Query(ctx, findPaginatedPublishedLessonsBySlugsAndSectionIDWithProgress,
		arg.UserID,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressRow{}
	for rows.Next() {
		var i FindPaginatedPublishedLessonsBySlugsAndSectionIDWithProgressRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Position,
			&i.IsPublished,
			&i.WatchTimeSeconds,
			&i.ReadTimeSeconds,
			&i.AuthorID,
			&i.LanguageSlug,
			&i.SeriesSlug,
			&i.SectionID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LessonProgressCompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPublishedLessonBySlugsAndIDs = `-- name: FindPublishedLessonBySlugsAndIDs :one
SELECT id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at FROM "lessons"
WHERE
  "language_slug" = $1 AND
  "series_slug" = $2 AND
  "section_id" = $3 AND
  "id" = $4 AND
  "is_published" = true
LIMIT 1
`

type FindPublishedLessonBySlugsAndIDsParams struct {
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	ID           int32
}

func (q *Queries) FindPublishedLessonBySlugsAndIDs(ctx context.Context, arg FindPublishedLessonBySlugsAndIDsParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, findPublishedLessonBySlugsAndIDs,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.ID,
	)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findPublishedLessonBySlugsAndIDsWithProgressArticleAndVideo = `-- name: FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideo :one
SELECT
    lessons.id, lessons.title, lessons.position, lessons.is_published, lessons.watch_time_seconds, lessons.read_time_seconds, lessons.author_id, lessons.language_slug, lessons.series_slug, lessons.section_id, lessons.created_at, lessons.updated_at,
    "lesson_progress"."completed_at" AS "lesson_progress_completed_at",
    "lesson_articles"."id" AS "lesson_acticle_id",
    "lesson_articles"."content" AS "lesson_article_content",
    "lesson_videos"."id" AS "lesson_video_id",
    "lesson_videos"."url" AS "lesson_video_url"
FROM "lessons"
LEFT JOIN "lesson_progress" ON (
    "lessons"."id" = "lesson_progress"."lesson_id" AND
    "lesson_progress"."user_id" = $1
)
LEFT JOIN "lesson_articles" ON "lessons"."id" = "lesson_articles"."lesson_id"
LEFT JOIN "lesson_videos" ON "lessons"."id" = "lesson_videos"."lesson_id"
WHERE
    "lessons"."language_slug" = $2 AND
    "lessons"."series_slug" = $3 AND
    "lessons"."section_id" = $4 AND
    "lessons"."id" = $5 AND
    "lessons"."is_published" = true
LIMIT 1
`

type FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideoParams struct {
	UserID       int32
	LanguageSlug string
	SeriesSlug   string
	SectionID    int32
	ID           int32
}

type FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideoRow struct {
	ID                        int32
	Title                     string
	Position                  int16
	IsPublished               bool
	WatchTimeSeconds          int32
	ReadTimeSeconds           int32
	AuthorID                  int32
	LanguageSlug              string
	SeriesSlug                string
	SectionID                 int32
	CreatedAt                 pgtype.Timestamp
	UpdatedAt                 pgtype.Timestamp
	LessonProgressCompletedAt pgtype.Timestamp
	LessonActicleID           pgtype.Int4
	LessonArticleContent      pgtype.Text
	LessonVideoID             pgtype.Int4
	LessonVideoUrl            pgtype.Text
}

func (q *Queries) FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideo(ctx context.Context, arg FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideoParams) (FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideoRow, error) {
	row := q.db.QueryRow(ctx, findPublishedLessonBySlugsAndIDsWithProgressArticleAndVideo,
		arg.UserID,
		arg.LanguageSlug,
		arg.SeriesSlug,
		arg.SectionID,
		arg.ID,
	)
	var i FindPublishedLessonBySlugsAndIDsWithProgressArticleAndVideoRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LessonProgressCompletedAt,
		&i.LessonActicleID,
		&i.LessonArticleContent,
		&i.LessonVideoID,
		&i.LessonVideoUrl,
	)
	return i, err
}

const incrementLessonPosition = `-- name: IncrementLessonPosition :exec
UPDATE "lessons" SET
  "position" = "position" + 1
WHERE
  "section_id" = $1 AND
  "position" < $2 AND
  "position" >= $3
`

type IncrementLessonPositionParams struct {
	SectionID  int32
	Position   int16
	Position_2 int16
}

func (q *Queries) IncrementLessonPosition(ctx context.Context, arg IncrementLessonPositionParams) error {
	_, err := q.db.Exec(ctx, incrementLessonPosition, arg.SectionID, arg.Position, arg.Position_2)
	return err
}

const updateLesson = `-- name: UpdateLesson :one
UPDATE "lessons" SET
  "title" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at
`

type UpdateLessonParams struct {
	Title string
	ID    int32
}

func (q *Queries) UpdateLesson(ctx context.Context, arg UpdateLessonParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLesson, arg.Title, arg.ID)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonIsPublished = `-- name: UpdateLessonIsPublished :one
UPDATE "lessons" SET
  "is_published" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at
`

type UpdateLessonIsPublishedParams struct {
	IsPublished bool
	ID          int32
}

func (q *Queries) UpdateLessonIsPublished(ctx context.Context, arg UpdateLessonIsPublishedParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLessonIsPublished, arg.IsPublished, arg.ID)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonPosition = `-- name: UpdateLessonPosition :one
UPDATE "lessons" SET
  "position" = $1
WHERE "id" = $2
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at
`

type UpdateLessonPositionParams struct {
	Position int16
	ID       int32
}

func (q *Queries) UpdateLessonPosition(ctx context.Context, arg UpdateLessonPositionParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLessonPosition, arg.Position, arg.ID)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLessonReadTimeSeconds = `-- name: UpdateLessonReadTimeSeconds :exec
UPDATE "lessons" SET
  "read_time_seconds" = $1
WHERE "id" = $2
`

type UpdateLessonReadTimeSecondsParams struct {
	ReadTimeSeconds int32
	ID              int32
}

func (q *Queries) UpdateLessonReadTimeSeconds(ctx context.Context, arg UpdateLessonReadTimeSecondsParams) error {
	_, err := q.db.Exec(ctx, updateLessonReadTimeSeconds, arg.ReadTimeSeconds, arg.ID)
	return err
}

const updateLessonWatchTimeSeconds = `-- name: UpdateLessonWatchTimeSeconds :exec
UPDATE "lessons" SET
  "watch_time_seconds" = $1
WHERE "id" = $2
`

type UpdateLessonWatchTimeSecondsParams struct {
	WatchTimeSeconds int32
	ID               int32
}

func (q *Queries) UpdateLessonWatchTimeSeconds(ctx context.Context, arg UpdateLessonWatchTimeSecondsParams) error {
	_, err := q.db.Exec(ctx, updateLessonWatchTimeSeconds, arg.WatchTimeSeconds, arg.ID)
	return err
}

const updateLessonWithPosition = `-- name: UpdateLessonWithPosition :one
UPDATE "lessons" SET
  "title" = $1,
  "position" = $2
WHERE "id" = $3
RETURNING id, title, position, is_published, watch_time_seconds, read_time_seconds, author_id, language_slug, series_slug, section_id, created_at, updated_at
`

type UpdateLessonWithPositionParams struct {
	Title    string
	Position int16
	ID       int32
}

func (q *Queries) UpdateLessonWithPosition(ctx context.Context, arg UpdateLessonWithPositionParams) (Lesson, error) {
	row := q.db.QueryRow(ctx, updateLessonWithPosition, arg.Title, arg.Position, arg.ID)
	var i Lesson
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Position,
		&i.IsPublished,
		&i.WatchTimeSeconds,
		&i.ReadTimeSeconds,
		&i.AuthorID,
		&i.LanguageSlug,
		&i.SeriesSlug,
		&i.SectionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
