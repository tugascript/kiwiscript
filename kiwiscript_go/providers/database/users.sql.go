// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const confirmUser = `-- name: ConfirmUser :one
UPDATE "users" SET
  "is_confirmed" = true,
  "version" = "version" + 1
WHERE "id" = $1
RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

func (q *Queries) ConfirmUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, confirmUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithPassword = `-- name: CreateUserWithPassword :one

INSERT INTO "users" (
  "first_name",
  "last_name",
  "location",
  "email",
  "password",
  "is_confirmed"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  false
) RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

type CreateUserWithPasswordParams struct {
	FirstName string
	LastName  string
	Location  string
	Email     string
	Password  pgtype.Text
}

// Copyright (C) 2024 Afonso Barracha
//
// This file is part of KiwiScript.
//
// KiwiScript is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// KiwiScript is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with KiwiScript.  If not, see <https://www.gnu.org/licenses/>.
func (q *Queries) CreateUserWithPassword(ctx context.Context, arg CreateUserWithPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithPassword,
		arg.FirstName,
		arg.LastName,
		arg.Location,
		arg.Email,
		arg.Password,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWithoutPassword = `-- name: CreateUserWithoutPassword :one
INSERT INTO "users" (
  "first_name",
  "last_name",
  "location",
  "email",
  "is_confirmed"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  true
) RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

type CreateUserWithoutPasswordParams struct {
	FirstName string
	LastName  string
	Location  string
	Email     string
}

func (q *Queries) CreateUserWithoutPassword(ctx context.Context, arg CreateUserWithoutPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserWithoutPassword,
		arg.FirstName,
		arg.LastName,
		arg.Location,
		arg.Email,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAllUsers = `-- name: DeleteAllUsers :exec
DELETE FROM "users"
`

func (q *Queries) DeleteAllUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllUsers)
	return err
}

const deleteUserById = `-- name: DeleteUserById :exec
DELETE FROM "users"
WHERE "id" = $1
`

func (q *Queries) DeleteUserById(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUserById, id)
	return err
}

const findStaffUserByIdWithProfileAndPicture = `-- name: FindStaffUserByIdWithProfileAndPicture :one
SELECT
    users.id, users.first_name, users.last_name, users.location, users.email, users.version, users.is_admin, users.is_staff, users.is_confirmed, users.password, users.created_at, users.updated_at,
    "user_profiles"."id" AS "profile_id",
    "user_profiles"."bio" AS "profile_bio",
    "user_profiles"."github" AS "profile_github",
    "user_profiles"."linkedin" AS "profile_linkedin",
    "user_profiles"."website" AS "profile_website",
    "user_pictures"."id" AS "picture_id",
    "user_pictures"."ext" AS "picture_ext"
FROM "users"
LEFT JOIN "user_profiles" ON "users"."id" = "user_profiles"."user_id"
LEFT JOIN "user_pictures" ON "users"."id" = "user_pictures"."user_id"
WHERE "users"."id" = $1 AND "users"."is_staff" = true LIMIT 1
`

type FindStaffUserByIdWithProfileAndPictureRow struct {
	ID              int32
	FirstName       string
	LastName        string
	Location        string
	Email           string
	Version         int16
	IsAdmin         bool
	IsStaff         bool
	IsConfirmed     bool
	Password        pgtype.Text
	CreatedAt       pgtype.Timestamp
	UpdatedAt       pgtype.Timestamp
	ProfileID       pgtype.Int4
	ProfileBio      pgtype.Text
	ProfileGithub   pgtype.Text
	ProfileLinkedin pgtype.Text
	ProfileWebsite  pgtype.Text
	PictureID       pgtype.UUID
	PictureExt      pgtype.Text
}

func (q *Queries) FindStaffUserByIdWithProfileAndPicture(ctx context.Context, id int32) (FindStaffUserByIdWithProfileAndPictureRow, error) {
	row := q.db.QueryRow(ctx, findStaffUserByIdWithProfileAndPicture, id)
	var i FindStaffUserByIdWithProfileAndPictureRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProfileID,
		&i.ProfileBio,
		&i.ProfileGithub,
		&i.ProfileLinkedin,
		&i.ProfileWebsite,
		&i.PictureID,
		&i.PictureExt,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at FROM "users"
WHERE "email" = $1 LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at FROM "users"
WHERE "id" = $1 LIMIT 1
`

func (q *Queries) FindUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "users" SET
  "first_name" = $1,
  "last_name" = $2,
  "location" = $3
WHERE "id" = $4
RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

type UpdateUserParams struct {
	FirstName string
	LastName  string
	Location  string
	ID        int32
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.FirstName,
		arg.LastName,
		arg.Location,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserEmail = `-- name: UpdateUserEmail :one
UPDATE "users" SET
  "email" = $1,
  "version" = "version" + 1
WHERE "id" = $2
RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

type UpdateUserEmailParams struct {
	Email string
	ID    int32
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserEmail, arg.Email, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserIsStaff = `-- name: UpdateUserIsStaff :exec
UPDATE "users" SET
  "is_staff" = $1,
  "version" = "version" + 1
WHERE "id" = $2
`

type UpdateUserIsStaffParams struct {
	IsStaff bool
	ID      int32
}

func (q *Queries) UpdateUserIsStaff(ctx context.Context, arg UpdateUserIsStaffParams) error {
	_, err := q.db.Exec(ctx, updateUserIsStaff, arg.IsStaff, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE "users" SET
  "password" = $1,
  "version" = "version" + 1
WHERE "id" = $2
RETURNING id, first_name, last_name, location, email, version, is_admin, is_staff, is_confirmed, password, created_at, updated_at
`

type UpdateUserPasswordParams struct {
	Password pgtype.Text
	ID       int32
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.Password, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Location,
		&i.Email,
		&i.Version,
		&i.IsAdmin,
		&i.IsStaff,
		&i.IsConfirmed,
		&i.Password,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
